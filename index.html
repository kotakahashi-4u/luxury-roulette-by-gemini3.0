<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grand Roulette - Auto Palette</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700;900&display=swap" rel="stylesheet">
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <style>
        body {
            font-family: 'Noto Sans JP', sans-serif;
            background-color: #0f172a; /* slate-900 */
            color: white;
            overflow: hidden;
            user-select: none;
        }
        
        /* Custom Animations */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-fadeIn {
            animation: fadeIn 0.3s ease-out forwards;
        }
        
        @keyframes bounceIn {
            0% { transform: scale(0.5); opacity: 0; }
            60% { transform: scale(1.05); opacity: 1; }
            100% { transform: scale(1); }
        }
        .animate-bounce-in {
            animation: bounceIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }

        @keyframes pulseSlow {
            0%, 100% { opacity: 1; }
            50% { opacity: .5; }
        }
        .animate-pulse-slow {
            animation: pulseSlow 3s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        /* Scrollbar for settings */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1e293b; 
        }
        ::-webkit-scrollbar-thumb {
            background: #475569; 
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #64748b; 
        }

        /* Checkbox Style */
        .toggle-checkbox:checked {
            right: 0;
            border-color: #eab308;
        }
        .toggle-checkbox:checked + .toggle-label {
            background-color: #eab308;
        }
    </style>
</head>
<body class="bg-slate-900 text-white min-h-screen flex flex-col relative overflow-hidden">

    <!-- Confetti Canvas -->
    <canvas id="confettiCanvas" class="fixed inset-0 pointer-events-none z-50"></canvas>

    <!-- Background Ambience -->
    <div class="absolute inset-0 overflow-hidden pointer-events-none">
        <div class="absolute top-0 left-0 w-full h-full bg-[radial-gradient(circle_at_center,_var(--tw-gradient-stops))] from-slate-800 via-slate-900 to-black opacity-80"></div>
        <div class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-[800px] h-[800px] bg-yellow-500/5 rounded-full blur-3xl"></div>
    </div>

    <!-- UI Controls -->
    <!-- Settings Toggle -->
    <button id="settingsToggleBtn" class="fixed top-4 left-4 z-40 p-3 rounded-full shadow-lg transition-all duration-300 bg-yellow-500 text-black hover:scale-110 hover:shadow-yellow-500/50">
        <i data-lucide="settings" class="w-6 h-6"></i>
    </button>

    <!-- Sound Toggle -->
    <button id="soundToggleBtn" class="fixed top-4 right-4 z-40 p-3 bg-slate-800/50 backdrop-blur rounded-full hover:bg-slate-700 transition-colors border border-slate-600">
        <i id="soundIcon" data-lucide="volume-2" class="w-6 h-6 text-green-400"></i>
    </button>

    <!-- Settings Panel -->
    <div id="settingsPanel" class="fixed inset-y-0 left-0 z-30 w-full md:w-96 bg-slate-900/95 backdrop-blur-xl border-r border-slate-700 shadow-2xl transform -translate-x-full transition-transform duration-500 ease-in-out overflow-y-auto">
        <div class="p-6 pt-20">
            <h2 class="text-2xl font-bold mb-6 text-yellow-400 flex items-center gap-2">
                <i data-lucide="settings" class="w-6 h-6"></i> 設定
            </h2>
            
            <!-- Reset Button -->
            <div class="mb-4 flex justify-between items-center">
                 <span class="text-sm text-slate-400">カスタマイズ</span>
                <button id="resetStorageBtn" class="text-xs text-slate-400 hover:text-red-400 underline">
                    初期設定に戻す
                </button>
            </div>

            <!-- Shuffle Toggle -->
            <div class="bg-slate-800 p-4 rounded-xl border border-slate-700 shadow-sm mb-4 flex items-center justify-between">
                <div>
                    <div class="font-bold text-sm text-white">項目を散らばらせる</div>
                    <div class="text-xs text-slate-400">比率に応じて分割・シャッフルします</div>
                </div>
                <div class="relative inline-block w-12 mr-2 align-middle select-none transition duration-200 ease-in">
                    <input type="checkbox" name="toggle" id="shuffleToggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer border-slate-600 transition-all duration-300 left-0"/>
                    <label for="shuffleToggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-slate-700 cursor-pointer border border-slate-600"></label>
                </div>
            </div>

            <!-- Auto Palette Button -->
            <div class="mb-6">
                <button id="autoPaletteBtn" class="w-full py-2 px-4 bg-gradient-to-r from-indigo-500 to-purple-600 rounded-xl text-white font-bold shadow-lg hover:shadow-indigo-500/30 hover:scale-[1.02] transition-all flex items-center justify-center gap-2">
                    <i data-lucide="palette" class="w-5 h-5"></i> 配色お任せ (オート)
                </button>
                <div id="paletteNameDisplay" class="text-xs text-center text-slate-400 mt-2 h-4 transition-all duration-300">
                    <!-- Palette name will appear here -->
                </div>
            </div>

            <div id="segmentsList" class="space-y-4">
                <!-- Segments will be injected here via JS -->
            </div>

            <button id="addSegmentBtn" class="w-full mt-6 py-3 border-2 border-dashed border-slate-600 rounded-xl text-slate-400 hover:border-yellow-500 hover:text-yellow-500 transition-colors flex items-center justify-center gap-2 font-bold">
                <i data-lucide="plus" class="w-5 h-5"></i> 項目を追加
            </button>
            
            <div class="h-20"></div> <!-- Spacer -->
        </div>
    </div>

    <!-- Main Game Area -->
    <div class="flex-1 flex flex-col items-center justify-center p-4 relative z-10">
        
        <!-- Title -->
        <div id="gameTitle" class="transition-all duration-500 opacity-100 scale-100">
            <h1 class="text-4xl md:text-6xl font-black text-transparent bg-clip-text bg-gradient-to-b from-yellow-300 to-yellow-600 drop-shadow-[0_0_15px_rgba(234,179,8,0.5)] mb-8 tracking-wider text-center">
                GRAND ROULETTE
            </h1>
        </div>

        <!-- Wheel Container -->
        <div class="relative group">
            <!-- Pointer -->
            <div class="absolute -top-6 left-1/2 -translate-x-1/2 z-20 pointer-events-none drop-shadow-xl">
                <div class="w-0 h-0 border-l-[20px] border-l-transparent border-r-[20px] border-r-transparent border-t-[40px] border-t-red-500 filter drop-shadow-lg"></div>
            </div>

            <!-- Wheel Canvas -->
            <div class="relative rounded-full overflow-hidden shadow-[0_0_50px_rgba(0,0,0,0.8)] border-4 border-slate-800">
                <canvas id="wheelCanvas" width="600" height="600" class="rounded-full w-[min(90vw,500px)] h-[min(90vw,500px)]"></canvas>
                <!-- Gloss Overlay -->
                <div class="absolute inset-0 rounded-full bg-gradient-to-tr from-white/10 to-transparent pointer-events-none"></div>
            </div>

            <!-- Spin Button -->
            <div class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 z-20">
                <button id="spinBtn" class="w-24 h-24 rounded-full font-bold text-xl shadow-[0_0_30px_rgba(0,0,0,0.5)] border-4 border-yellow-500/50 transition-all duration-200 flex items-center justify-center tracking-widest bg-gradient-to-br from-red-600 to-red-800 text-white hover:scale-110 hover:shadow-[0_0_50px_rgba(220,38,38,0.6)] animate-pulse-slow">
                    SPIN
                </button>
            </div>
        </div>
    </div>

    <!-- Winner Modal -->
    <div id="winnerModal" class="fixed inset-0 z-50 flex items-center justify-center p-4 hidden">
        <div class="absolute inset-0 bg-black/70 backdrop-blur-sm" id="modalOverlay"></div>
        <div class="relative bg-slate-900 border-2 border-yellow-500 rounded-3xl p-8 md:p-12 max-w-lg w-full text-center shadow-[0_0_100px_rgba(234,179,8,0.3)] animate-bounce-in">
            <button id="closeModalBtn" class="absolute top-4 right-4 text-slate-400 hover:text-white transition-colors">
                <i data-lucide="x" class="w-6 h-6"></i>
            </button>
            
            <div class="mb-6 flex justify-center">
                <div class="bg-yellow-500/20 p-6 rounded-full">
                    <i data-lucide="trophy" class="w-16 h-16 text-yellow-400"></i>
                </div>
            </div>
            
            <h3 class="text-yellow-500 text-xl font-bold tracking-widest mb-2 uppercase">Winner</h3>
            <div id="winnerName" class="text-4xl md:text-5xl font-black text-white mb-8 leading-tight">
                -
            </div>
            
            <button id="modalCloseActionBtn" class="px-8 py-3 bg-gradient-to-r from-yellow-500 to-yellow-600 text-black font-bold rounded-full text-lg hover:shadow-[0_0_20px_rgba(234,179,8,0.5)] transform hover:-translate-y-1 transition-all">
                Close
            </button>
        </div>
    </div>

    <script>
        // --- Sound Logic ---
        class SoundFX {
            constructor() {
                this.ctx = null;
                this.enabled = true;
            }

            init() {
                if (!this.ctx) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            }

            playTick() {
                if (!this.enabled || !this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(800, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(300, this.ctx.currentTime + 0.05);
                
                gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.05);

                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.05);
            }

            playWin() {
                if (!this.enabled || !this.ctx) return;
                const now = this.ctx.currentTime;
                const notes = [523.25, 659.25, 783.99, 1046.50, 783.99, 1046.50]; // C Major arpeggio
                
                notes.forEach((freq, i) => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    
                    const startTime = now + (i * 0.1);
                    const duration = 0.4;
                    
                    gain.gain.setValueAtTime(0, startTime);
                    gain.gain.linearRampToValueAtTime(0.3, startTime + 0.05);
                    gain.gain.exponentialRampToValueAtTime(0.01, startTime + duration);
                    
                    osc.connect(gain);
                    gain.connect(this.ctx.destination);
                    osc.start(startTime);
                    osc.stop(startTime + duration);
                });
            }
        }

        // --- Confetti Logic ---
        class ConfettiSystem {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.particles = [];
                this.active = false;
                this.animationId = null;
                this.colors = ['#FFD700', '#FF0000', '#00FF00', '#0000FF', '#FF00FF', '#00FFFF', '#FFFFFF'];
                
                this.resize = this.resize.bind(this);
                window.addEventListener('resize', this.resize);
                this.resize();
            }

            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            start() {
                this.active = true;
                this.particles = [];
                for (let i = 0; i < 150; i++) {
                    this.particles.push({
                        x: window.innerWidth / 2,
                        y: window.innerHeight / 2,
                        vx: (Math.random() - 0.5) * 20,
                        vy: (Math.random() - 0.5) * 20 - 5,
                        gravity: 0.2,
                        color: this.colors[Math.floor(Math.random() * this.colors.length)],
                        size: Math.random() * 8 + 4,
                        rotation: Math.random() * 360,
                        rotationSpeed: (Math.random() - 0.5) * 10
                    });
                }
                this.animate();
            }

            stop() {
                this.active = false;
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                if (this.animationId) cancelAnimationFrame(this.animationId);
            }

            animate() {
                if (!this.active) return;
                
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.particles.forEach((p) => {
                    p.vy += p.gravity;
                    p.x += p.vx;
                    p.y += p.vy;
                    p.rotation += p.rotationSpeed;
                    p.vx *= 0.99;

                    this.ctx.save();
                    this.ctx.translate(p.x, p.y);
                    this.ctx.rotate((p.rotation * Math.PI) / 180);
                    this.ctx.fillStyle = p.color;
                    this.ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
                    this.ctx.restore();
                });

                // Remove off-screen
                this.particles = this.particles.filter(p => p.y < this.canvas.height + 50);

                if (this.particles.length > 0) {
                    this.animationId = requestAnimationFrame(this.animate.bind(this));
                } else {
                    this.active = false;
                }
            }
        }

        // --- Color Palette System ---
        // Refined palettes inspired by design tools
        const COLOR_PALETTES = [
            { name: "ポップ & キュート", colors: ["#FF6B6B", "#FFD93D", "#6BCB77", "#4D96FF", "#FF9F45", "#F78FB3"] },
            { name: "北欧ナチュラル", colors: ["#8D9F87", "#D4CBB6", "#E39E5C", "#A64B2A", "#5F4B3B", "#CCD5AE"] },
            { name: "アーバン・シック", colors: ["#2C3E50", "#E74C3C", "#ECF0F1", "#3498DB", "#F39C12", "#95A5A6"] },
            { name: "和の伝統色 (雅)", colors: ["#D75455", "#E5B350", "#6A846E", "#594F4F", "#8C708D", "#F2EBBF"] },
            { name: "ドリーミーパステル", colors: ["#FFB7B2", "#FFDAC1", "#E2F0CB", "#B5EAD7", "#C7CEEA", "#F6EAC2"] },
            { name: "フレッシュフルーツ", colors: ["#FF5E0E", "#F9CE00", "#76B900", "#00A4CC", "#F2385A", "#E9F1DF"] },
            { name: "オーシャンブルー", colors: ["#05445E", "#189AB4", "#75E6DA", "#D4F1F4", "#006E90", "#A8D8EA"] },
            { name: "エレガントローズ", colors: ["#773344", "#E3B5A4", "#F5E9E2", "#0B0014", "#D44D5C", "#BFB5B2"] },
            { name: "レトロモダン", colors: ["#E63946", "#F1FAEE", "#A8DADC", "#457B9D", "#1D3557", "#2A9D8F"] },
            { name: "アースカラー", colors: ["#606c38", "#283618", "#fefae0", "#dda15e", "#bc6c25", "#A3B18A"] },
            { name: "ヴィンテージサーカス", colors: ["#420039", "#93003a", "#ff4f00", "#ffaa00", "#ff0010", "#d6d6d6"] },
            { name: "春の訪れ", colors: ["#ff9a9e", "#fad0c4", "#ffecd2", "#fcb69f", "#a18cd1", "#fbc2eb"] }
        ];

        // Helper to check brightness and return black or white text
        function getContrastColor(hex) {
            // Remove hash
            if (hex.indexOf('#') === 0) {
                hex = hex.slice(1);
            }
            // Parse r, g, b
            if (hex.length === 3) {
                hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
            }
            if (hex.length !== 6) {
                return '#FFFFFF';
            }
            var r = parseInt(hex.substring(0, 2), 16);
            var g = parseInt(hex.substring(2, 4), 16);
            var b = parseInt(hex.substring(4, 6), 16);
            // YIQ equation
            var yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
            // Slightly adjusted threshold for better readability on mid-tones
            return (yiq >= 140) ? '#000000' : '#FFFFFF';
        }

        // --- Storage Logic ---
        const STORAGE_KEY = 'grand_roulette_settings_v2';

        function saveToStorage(stateData) {
            try {
                const data = {
                    segments: stateData.segments,
                    shuffle: stateData.shuffle
                };
                localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
            } catch (e) {
                console.warn('Failed to save settings:', e);
            }
        }

        function loadFromStorage() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (saved) {
                    const parsed = JSON.parse(saved);
                    if (Array.isArray(parsed)) {
                        return { segments: parsed, shuffle: false };
                    }
                    return parsed;
                }
                const savedV1 = localStorage.getItem('grand_roulette_settings_v1');
                if (savedV1) {
                    return { segments: JSON.parse(savedV1), shuffle: false };
                }
                return null;
            } catch (e) {
                console.warn('Failed to load settings:', e);
                return null;
            }
        }

        function clearStorage() {
            try {
                localStorage.removeItem(STORAGE_KEY);
                localStorage.removeItem('grand_roulette_settings_v1');
                location.reload(); 
            } catch (e) {
                console.warn('Failed to clear storage:', e);
            }
        }

        // --- Main App Logic ---
        const soundFX = new SoundFX();
        const confetti = new ConfettiSystem('confettiCanvas');
        
        // Initial Defaults
        const defaultSegments = [
            { id: 1, text: '特賞: 旅行券', weight: 1, color: '#E63946', textColor: '#FFFFFF' },
            { id: 2, text: '和牛ステーキ', weight: 3, color: '#F1FAEE', textColor: '#000000' },
            { id: 3, text: 'アマギフ 5k', weight: 5, color: '#A8DADC', textColor: '#000000' },
            { id: 4, text: 'お菓子詰め合わせ', weight: 10, color: '#457B9D', textColor: '#FFFFFF' },
            { id: 5, text: 'ハズレ', weight: 20, color: '#1D3557', textColor: '#FFFFFF' },
            { id: 6, text: 'もう一回', weight: 5, color: '#2A9D8F', textColor: '#FFFFFF' },
        ];

        // Load or Default
        const loadedData = loadFromStorage();
        const initialSegments = loadedData ? loadedData.segments : defaultSegments;
        const initialShuffle = loadedData ? (loadedData.shuffle || false) : false;

        // Initial State
        let state = {
            segments: initialSegments,
            shuffle: initialShuffle,
            activeSegments: [], 
            isSpinning: false,
            rotation: 0,
            soundEnabled: true,
            showSettings: false
        };

        // DOM Elements
        const canvas = document.getElementById('wheelCanvas');
        const ctx = canvas.getContext('2d');
        const spinBtn = document.getElementById('spinBtn');
        const settingsPanel = document.getElementById('settingsPanel');
        const settingsToggleBtn = document.getElementById('settingsToggleBtn');
        const segmentsList = document.getElementById('segmentsList');
        const addSegmentBtn = document.getElementById('addSegmentBtn');
        const autoPaletteBtn = document.getElementById('autoPaletteBtn');
        const paletteNameDisplay = document.getElementById('paletteNameDisplay');
        const soundToggleBtn = document.getElementById('soundToggleBtn');
        const winnerModal = document.getElementById('winnerModal');
        const winnerName = document.getElementById('winnerName');
        const closeModalBtn = document.getElementById('closeModalBtn');
        const modalCloseActionBtn = document.getElementById('modalCloseActionBtn');
        const modalOverlay = document.getElementById('modalOverlay');
        const gameTitle = document.getElementById('gameTitle');
        const resetStorageBtn = document.getElementById('resetStorageBtn');
        const shuffleToggle = document.getElementById('shuffleToggle');

        // Constants
        const CANVAS_SIZE = 600;
        const CENTER = CANVAS_SIZE / 2;
        const RADIUS = CANVAS_SIZE / 2 - 20;

        // --- Functions ---

        function recalculateActiveSegments() {
            if (!state.shuffle) {
                // Normal Mode
                state.activeSegments = state.segments.map(s => ({
                    ...s,
                    originalId: s.id,
                    displayWeight: parseInt(s.weight)
                }));
            } else {
                // Shuffle Mode
                let list = [];
                state.segments.forEach(seg => {
                    const count = parseInt(seg.weight);
                    for(let i=0; i<count; i++) {
                        list.push({
                            ...seg,
                            originalId: seg.id,
                            displayWeight: 1 
                        });
                    }
                });
                
                // Fisher-Yates Shuffle
                for (let i = list.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [list[i], list[j]] = [list[j], list[i]];
                }
                
                state.activeSegments = list;
            }
        }

        function drawWheel() {
            ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            canvas.style.transform = `rotate(${state.rotation}deg)`;

            const totalDisplayWeight = state.activeSegments.reduce((acc, seg) => acc + seg.displayWeight, 0);
            let currentAngle = 0;

            // 1. Draw Segments
            state.activeSegments.forEach((seg) => {
                const sliceAngle = (seg.displayWeight / totalDisplayWeight) * 2 * Math.PI;
                
                // Wedge
                ctx.beginPath();
                ctx.moveTo(CENTER, CENTER);
                ctx.arc(CENTER, CENTER, RADIUS, currentAngle, currentAngle + sliceAngle);
                ctx.closePath();
                ctx.fillStyle = seg.color;
                ctx.fill();
                ctx.strokeStyle = '#rgba(0,0,0,0.1)';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Text
                ctx.save();
                ctx.translate(CENTER, CENTER);
                ctx.rotate(currentAngle + sliceAngle / 2);
                ctx.textAlign = 'right';
                ctx.fillStyle = seg.textColor;
                
                const angleDeg = (sliceAngle * 180) / Math.PI;
                let fontSize = 24;
                if (angleDeg < 10) fontSize = 12;
                else if (angleDeg < 20) fontSize = 16;
                
                ctx.font = `bold ${fontSize}px "Noto Sans JP", sans-serif`;
                ctx.shadowColor = 'rgba(0,0,0,0.3)';
                ctx.shadowBlur = 2;
                
                if (angleDeg > 3) {
                     ctx.fillText(seg.text, RADIUS - 40, fontSize/3);
                }
                
                ctx.restore();

                currentAngle += sliceAngle;
            });
            
            // 2. Draw Outer Border
            ctx.beginPath();
            ctx.arc(CENTER, CENTER, RADIUS, 0, Math.PI * 2);
            ctx.lineWidth = 6;
            ctx.strokeStyle = '#D4AF37'; 
            ctx.stroke();
            
            ctx.beginPath();
            ctx.arc(CENTER, CENTER, RADIUS + 8, 0, Math.PI * 2);
            ctx.lineWidth = 12;
            ctx.strokeStyle = '#1e293b'; // slate-800
            ctx.stroke();

            // 3. Inner Center Decoration
            ctx.beginPath();
            ctx.arc(CENTER, CENTER, 40, 0, Math.PI * 2);
            ctx.fillStyle = '#222';
            ctx.fill();
            ctx.lineWidth = 4;
            ctx.strokeStyle = '#D4AF37';
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(CENTER, CENTER, 15, 0, Math.PI * 2);
            ctx.fillStyle = '#D4AF37';
            ctx.fill();
        }

        function renderSettings() {
            shuffleToggle.checked = state.shuffle;

            segmentsList.innerHTML = '';
            state.segments.forEach((seg, index) => {
                const div = document.createElement('div');
                div.className = 'bg-slate-800 p-4 rounded-xl border border-slate-700 shadow-sm animate-fadeIn';
                div.innerHTML = `
                    <div class="flex gap-2 mb-2">
                        <input type="text" value="${seg.text}" data-id="${seg.id}" class="seg-text flex-1 bg-slate-900 border border-slate-600 rounded px-3 py-1 text-sm focus:border-yellow-500 outline-none transition-colors" placeholder="項目名">
                        <input type="color" value="${seg.color}" data-id="${seg.id}" class="seg-color w-10 h-8 rounded cursor-pointer border-none bg-transparent">
                    </div>
                    <div class="flex items-center gap-4">
                        <div class="flex-1 flex flex-col">
                            <label class="text-xs text-slate-400 mb-1">比率 (確率): ${seg.weight}</label>
                            <input type="range" min="1" max="50" value="${seg.weight}" data-id="${seg.id}" class="seg-weight w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-yellow-500">
                        </div>
                        ${state.segments.length > 2 ? `<button data-id="${seg.id}" class="seg-delete p-2 text-red-400 hover:bg-red-400/10 rounded-full transition-colors"><i data-lucide="trash-2" class="w-4 h-4"></i></button>` : ''}
                    </div>
                `;
                segmentsList.appendChild(div);
            });
            lucide.createIcons();

            // Attach listeners
            document.querySelectorAll('.seg-text').forEach(el => {
                el.addEventListener('input', (e) => updateSegment(parseInt(e.target.dataset.id), 'text', e.target.value));
            });
            document.querySelectorAll('.seg-color').forEach(el => {
                el.addEventListener('input', (e) => updateSegment(parseInt(e.target.dataset.id), 'color', e.target.value));
            });
            document.querySelectorAll('.seg-weight').forEach(el => {
                el.addEventListener('input', (e) => updateSegment(parseInt(e.target.dataset.id), 'weight', parseInt(e.target.value)));
            });
            document.querySelectorAll('.seg-delete').forEach(el => {
                el.addEventListener('click', (e) => {
                    const id = parseInt(e.currentTarget.dataset.id);
                    removeSegment(id);
                });
            });
        }

        function updateSegment(id, field, value) {
            const seg = state.segments.find(s => s.id === id);
            if (seg) {
                seg[field] = value;
                
                // Automatically update text color if bg color changes (optional manual override is possible, but here we force constrast if needed)
                if (field === 'color') {
                    seg.textColor = getContrastColor(value);
                }

                recalculateActiveSegments();
                drawWheel();
                saveToStorage(state);
                
                if (field === 'weight') {
                     const label = document.querySelector(`input[data-id="${id}"].seg-weight`).previousElementSibling;
                     label.textContent = `比率 (確率): ${value}`;
                }
            }
        }

        function applyRandomPalette() {
            // Pick a random palette
            const palette = COLOR_PALETTES[Math.floor(Math.random() * COLOR_PALETTES.length)];
            const colors = palette.colors;
            
            // Apply to all segments sequentially
            state.segments.forEach((seg, index) => {
                const color = colors[index % colors.length];
                seg.color = color;
                seg.textColor = getContrastColor(color);
            });
            
            // Display Palette Name
            paletteNameDisplay.textContent = `適用中: ${palette.name}`;
            paletteNameDisplay.classList.add('text-yellow-400');
            setTimeout(() => paletteNameDisplay.classList.remove('text-yellow-400'), 500);

            // Visual feedback
            const btnIcon = autoPaletteBtn.querySelector('svg') || autoPaletteBtn.querySelector('i');
            
            if (btnIcon) {
                btnIcon.classList.add('animate-spin');
                setTimeout(() => btnIcon.classList.remove('animate-spin'), 500);
            }

            // Update UI
            renderSettings();
            recalculateActiveSegments();
            drawWheel();
            saveToStorage(state);
        }

        function addSegment() {
            const newId = (state.segments.length > 0 ? Math.max(...state.segments.map(s => s.id)) : 0) + 1;
            // Default gray
            state.segments.push({ id: newId, text: '新規項目', weight: 1, color: '#bdc3c7', textColor: '#000000' });
            renderSettings();
            recalculateActiveSegments();
            drawWheel();
            saveToStorage(state);
        }

        function removeSegment(id) {
            if (state.segments.length <= 2) return;
            state.segments = state.segments.filter(s => s.id !== id);
            renderSettings();
            recalculateActiveSegments();
            drawWheel();
            saveToStorage(state);
        }

        function toggleShuffle() {
            state.shuffle = shuffleToggle.checked;
            recalculateActiveSegments();
            drawWheel();
            saveToStorage(state);
        }

        function toggleSettings() {
            state.showSettings = !state.showSettings;
            if (state.showSettings) {
                settingsPanel.classList.remove('-translate-x-full');
                settingsToggleBtn.classList.add('bg-slate-800', 'text-white');
                settingsToggleBtn.classList.remove('bg-yellow-500', 'text-black');
                settingsToggleBtn.innerHTML = '<i data-lucide="chevron-left" class="w-6 h-6"></i>';
            } else {
                settingsPanel.classList.add('-translate-x-full');
                settingsToggleBtn.classList.remove('bg-slate-800', 'text-white');
                settingsToggleBtn.classList.add('bg-yellow-500', 'text-black');
                settingsToggleBtn.innerHTML = '<i data-lucide="settings" class="w-6 h-6"></i>';
            }
            lucide.createIcons();
        }

        function toggleSound() {
            state.soundEnabled = !state.soundEnabled;
            soundFX.enabled = state.soundEnabled;
            if (state.soundEnabled) {
                soundFX.init();
                document.getElementById('soundIcon').setAttribute('data-lucide', 'volume-2');
                document.getElementById('soundIcon').classList.replace('text-red-400', 'text-green-400');
            } else {
                document.getElementById('soundIcon').setAttribute('data-lucide', 'volume-x');
                document.getElementById('soundIcon').classList.replace('text-green-400', 'text-red-400');
            }
            lucide.createIcons();
        }

        function spin() {
            if (state.isSpinning) return;
            
            soundFX.init();
            state.isSpinning = true;
            
            // UI Update
            spinBtn.disabled = true;
            spinBtn.classList.add('bg-slate-800', 'text-slate-500', 'scale-90', 'cursor-not-allowed', 'opacity-80');
            spinBtn.classList.remove('bg-gradient-to-br', 'from-red-600', 'to-red-800', 'text-white', 'hover:scale-110', 'animate-pulse-slow');
            spinBtn.textContent = '...';
            gameTitle.classList.add('opacity-50', 'scale-90');
            
            if(state.showSettings) toggleSettings();

            // 1. Determine Winning Segment
            const totalWeight = state.segments.reduce((acc, seg) => acc + parseInt(seg.weight), 0);
            let random = Math.random() * totalWeight;
            let resultSegment = null;
            
            for (let seg of state.segments) {
                if (random < parseInt(seg.weight)) {
                    resultSegment = seg;
                    break;
                }
                random -= parseInt(seg.weight);
            }

            // 2. Find target slice
            const targetCandidates = [];
            let angleAccumulator = 0;
            const totalDisplayWeight = state.activeSegments.reduce((acc,s) => acc + s.displayWeight, 0);

            state.activeSegments.forEach(seg => {
                const segAngle = (seg.displayWeight / totalDisplayWeight) * 360;
                if (seg.originalId === resultSegment.id) {
                    targetCandidates.push({
                        start: angleAccumulator,
                        end: angleAccumulator + segAngle
                    });
                }
                angleAccumulator += segAngle;
            });

            const targetSlice = targetCandidates[Math.floor(Math.random() * targetCandidates.length)];

            // 3. Calculate Rotation
            const pad = Math.min((targetSlice.end - targetSlice.start) * 0.2, 5); 
            const randomOffset = Math.random() * (targetSlice.end - targetSlice.start - 2 * pad) + pad;
            const targetAngleWithinWheel = targetSlice.start + randomOffset;

            const spins = 5;
            const duration = 6000;
            const startRotation = state.rotation;
            
            const currentMod = startRotation % 360;
            const targetRotationBase = 270 - targetAngleWithinWheel; 
            const totalRotation = startRotation + (360 * spins) + (targetRotationBase - currentMod + 360) % 360;

            const startTime = performance.now();
            let lastTickSection = -1;

            const animate = (currentTime) => {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                const ease = 1 - Math.pow(1 - progress, 4);
                state.rotation = startRotation + (totalRotation - startRotation) * ease;
                
                canvas.style.transform = `rotate(${state.rotation}deg)`;

                const normRot = state.rotation % 360;
                let pointerAngleInWheel = (270 - normRot) % 360;
                if (pointerAngleInWheel < 0) pointerAngleInWheel += 360;

                let currentSegIndex = 0;
                let accum = 0;
                
                for(let i=0; i<state.activeSegments.length; i++) {
                    const w = (state.activeSegments[i].displayWeight / totalDisplayWeight) * 360;
                    if (pointerAngleInWheel >= accum && pointerAngleInWheel < accum + w) {
                        currentSegIndex = i;
                        break;
                    }
                    accum += w;
                }

                if (currentSegIndex !== lastTickSection) {
                    soundFX.playTick();
                    lastTickSection = currentSegIndex;
                }

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    finishSpin(resultSegment);
                }
            };

            requestAnimationFrame(animate);
        }

        function finishSpin(result) {
            state.isSpinning = false;
            soundFX.playWin();
            
            winnerName.textContent = result.text;
            winnerModal.classList.remove('hidden');
            confetti.start();

            spinBtn.disabled = false;
            spinBtn.classList.remove('bg-slate-800', 'text-slate-500', 'scale-90', 'cursor-not-allowed', 'opacity-80');
            spinBtn.classList.add('bg-gradient-to-br', 'from-red-600', 'to-red-800', 'text-white', 'hover:scale-110', 'animate-pulse-slow');
            spinBtn.textContent = 'SPIN';
            gameTitle.classList.remove('opacity-50', 'scale-90');
        }

        function closeWinnerModal() {
            winnerModal.classList.add('hidden');
            confetti.stop();
        }

        // --- Event Listeners & Init ---
        settingsToggleBtn.addEventListener('click', toggleSettings);
        soundToggleBtn.addEventListener('click', toggleSound);
        addSegmentBtn.addEventListener('click', addSegment);
        autoPaletteBtn.addEventListener('click', applyRandomPalette); // New Listener
        spinBtn.addEventListener('click', spin);
        resetStorageBtn.addEventListener('click', () => {
            if(confirm('設定をすべてリセットしますか？')) {
                clearStorage();
            }
        });
        shuffleToggle.addEventListener('change', toggleShuffle);
        
        closeModalBtn.addEventListener('click', closeWinnerModal);
        modalCloseActionBtn.addEventListener('click', closeWinnerModal);
        modalOverlay.addEventListener('click', closeWinnerModal);

        window.addEventListener('resize', () => {
             // Redraw if needed
        });

        // Initialize
        lucide.createIcons();
        renderSettings();
        recalculateActiveSegments();
        drawWheel();
        
    </script>
</body>
</html>
