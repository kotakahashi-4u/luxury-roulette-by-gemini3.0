<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grand Roulette</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700;900&display=swap" rel="stylesheet">
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <style>
        body {
            font-family: 'Noto Sans JP', sans-serif;
            background-color: #0f172a; /* slate-900 */
            color: white;
            overflow: hidden;
            user-select: none;
        }
        
        /* Custom Animations */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-fadeIn {
            animation: fadeIn 0.3s ease-out forwards;
        }
        
        @keyframes bounceIn {
            0% { transform: scale(0.5); opacity: 0; }
            60% { transform: scale(1.05); opacity: 1; }
            100% { transform: scale(1); }
        }
        .animate-bounce-in {
            animation: bounceIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }

        @keyframes pulseSlow {
            0%, 100% { opacity: 1; }
            50% { opacity: .5; }
        }
        .animate-pulse-slow {
            animation: pulseSlow 3s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        /* Scrollbar for settings */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1e293b; 
        }
        ::-webkit-scrollbar-thumb {
            background: #475569; 
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #64748b; 
        }

        /* Checkbox Style */
        .toggle-checkbox:checked {
            right: 0;
            border-color: #eab308;
        }
        .toggle-checkbox:checked + .toggle-label {
            background-color: #eab308;
        }
    </style>
</head>
<body class="bg-slate-900 text-white min-h-screen flex flex-col relative overflow-hidden">

    <!-- Confetti Canvas -->
    <canvas id="confettiCanvas" class="fixed inset-0 pointer-events-none z-50"></canvas>

    <!-- Background Ambience -->
    <div class="absolute inset-0 overflow-hidden pointer-events-none">
        <div class="absolute top-0 left-0 w-full h-full bg-[radial-gradient(circle_at_center,_var(--tw-gradient-stops))] from-slate-800 via-slate-900 to-black opacity-80"></div>
        <div class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-[800px] h-[800px] bg-yellow-500/5 rounded-full blur-3xl"></div>
    </div>

    <!-- UI Controls -->
    <!-- Settings Toggle -->
    <button id="settingsToggleBtn" class="fixed top-4 left-4 z-40 p-3 rounded-full shadow-lg transition-all duration-300 bg-yellow-500 text-black hover:scale-110 hover:shadow-yellow-500/50">
        <i data-lucide="settings" class="w-6 h-6"></i>
    </button>

    <!-- Sound Toggle -->
    <button id="soundToggleBtn" class="fixed top-4 right-4 z-40 p-3 bg-slate-800/50 backdrop-blur rounded-full hover:bg-slate-700 transition-colors border border-slate-600">
        <i id="soundIcon" data-lucide="volume-2" class="w-6 h-6 text-green-400"></i>
    </button>

    <!-- Settings Panel -->
    <div id="settingsPanel" class="fixed inset-y-0 left-0 z-30 w-full md:w-96 bg-slate-900/95 backdrop-blur-xl border-r border-slate-700 shadow-2xl transform -translate-x-full transition-transform duration-500 ease-in-out overflow-y-auto">
        <div class="p-6 pt-20">
            <h2 class="text-2xl font-bold mb-6 text-yellow-400 flex items-center gap-2">
                <i data-lucide="settings" class="w-6 h-6"></i> 設定
            </h2>
            
            <!-- Reset Button -->
            <div class="mb-4 flex justify-between items-center">
                 <span class="text-sm text-slate-400">カスタマイズ</span>
                <button id="resetStorageBtn" class="text-xs text-slate-400 hover:text-red-400 underline">
                    初期設定に戻す
                </button>
            </div>

            <!-- Shuffle Toggle -->
            <div class="bg-slate-800 p-4 rounded-xl border border-slate-700 shadow-sm mb-4 flex items-center justify-between">
                <div>
                    <div class="font-bold text-sm text-white">項目を散らばらせる</div>
                    <div class="text-xs text-slate-400">比率に応じて分割・シャッフルします</div>
                </div>
                <div class="relative inline-block w-12 mr-2 align-middle select-none transition duration-200 ease-in">
                    <input type="checkbox" name="toggle" id="shuffleToggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer border-slate-600 transition-all duration-300 left-0"/>
                    <label for="shuffleToggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-slate-700 cursor-pointer border border-slate-600"></label>
                </div>
            </div>

            <div id="segmentsList" class="space-y-4">
                <!-- Segments will be injected here via JS -->
            </div>

            <button id="addSegmentBtn" class="w-full mt-6 py-3 border-2 border-dashed border-slate-600 rounded-xl text-slate-400 hover:border-yellow-500 hover:text-yellow-500 transition-colors flex items-center justify-center gap-2 font-bold">
                <i data-lucide="plus" class="w-5 h-5"></i> 項目を追加
            </button>
            
            <div class="h-20"></div> <!-- Spacer -->
        </div>
    </div>

    <!-- Main Game Area -->
    <div class="flex-1 flex flex-col items-center justify-center p-4 relative z-10">
        
        <!-- Title -->
        <div id="gameTitle" class="transition-all duration-500 opacity-100 scale-100">
            <h1 class="text-4xl md:text-6xl font-black text-transparent bg-clip-text bg-gradient-to-b from-yellow-300 to-yellow-600 drop-shadow-[0_0_15px_rgba(234,179,8,0.5)] mb-8 tracking-wider text-center">
                GRAND ROULETTE
            </h1>
        </div>

        <!-- Wheel Container -->
        <div class="relative group">
            <!-- Pointer -->
            <div class="absolute -top-6 left-1/2 -translate-x-1/2 z-20 pointer-events-none drop-shadow-xl">
                <div class="w-0 h-0 border-l-[20px] border-l-transparent border-r-[20px] border-r-transparent border-t-[40px] border-t-red-500 filter drop-shadow-lg"></div>
            </div>

            <!-- Wheel Canvas -->
            <div class="relative rounded-full overflow-hidden shadow-[0_0_50px_rgba(0,0,0,0.8)] border-4 border-slate-800">
                <canvas id="wheelCanvas" width="600" height="600" class="rounded-full w-[min(90vw,500px)] h-[min(90vw,500px)]"></canvas>
                <!-- Gloss Overlay -->
                <div class="absolute inset-0 rounded-full bg-gradient-to-tr from-white/10 to-transparent pointer-events-none"></div>
            </div>

            <!-- Spin Button -->
            <div class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 z-20">
                <button id="spinBtn" class="w-24 h-24 rounded-full font-bold text-xl shadow-[0_0_30px_rgba(0,0,0,0.5)] border-4 border-yellow-500/50 transition-all duration-200 flex items-center justify-center tracking-widest bg-gradient-to-br from-red-600 to-red-800 text-white hover:scale-110 hover:shadow-[0_0_50px_rgba(220,38,38,0.6)] animate-pulse-slow">
                    SPIN
                </button>
            </div>
        </div>
    </div>

    <!-- Winner Modal -->
    <div id="winnerModal" class="fixed inset-0 z-50 flex items-center justify-center p-4 hidden">
        <div class="absolute inset-0 bg-black/70 backdrop-blur-sm" id="modalOverlay"></div>
        <div class="relative bg-slate-900 border-2 border-yellow-500 rounded-3xl p-8 md:p-12 max-w-lg w-full text-center shadow-[0_0_100px_rgba(234,179,8,0.3)] animate-bounce-in">
            <button id="closeModalBtn" class="absolute top-4 right-4 text-slate-400 hover:text-white transition-colors">
                <i data-lucide="x" class="w-6 h-6"></i>
            </button>
            
            <div class="mb-6 flex justify-center">
                <div class="bg-yellow-500/20 p-6 rounded-full">
                    <i data-lucide="trophy" class="w-16 h-16 text-yellow-400"></i>
                </div>
            </div>
            
            <h3 class="text-yellow-500 text-xl font-bold tracking-widest mb-2 uppercase">Winner</h3>
            <div id="winnerName" class="text-4xl md:text-5xl font-black text-white mb-8 leading-tight">
                -
            </div>
            
            <button id="modalCloseActionBtn" class="px-8 py-3 bg-gradient-to-r from-yellow-500 to-yellow-600 text-black font-bold rounded-full text-lg hover:shadow-[0_0_20px_rgba(234,179,8,0.5)] transform hover:-translate-y-1 transition-all">
                Close
            </button>
        </div>
    </div>

    <script>
        // --- Sound Logic ---
        class SoundFX {
            constructor() {
                this.ctx = null;
                this.enabled = true;
            }

            init() {
                if (!this.ctx) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            }

            playTick() {
                if (!this.enabled || !this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(800, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(300, this.ctx.currentTime + 0.05);
                
                gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.05);

                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.05);
            }

            playWin() {
                if (!this.enabled || !this.ctx) return;
                const now = this.ctx.currentTime;
                const notes = [523.25, 659.25, 783.99, 1046.50, 783.99, 1046.50]; // C Major arpeggio
                
                notes.forEach((freq, i) => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    
                    const startTime = now + (i * 0.1);
                    const duration = 0.4;
                    
                    gain.gain.setValueAtTime(0, startTime);
                    gain.gain.linearRampToValueAtTime(0.3, startTime + 0.05);
                    gain.gain.exponentialRampToValueAtTime(0.01, startTime + duration);
                    
                    osc.connect(gain);
                    gain.connect(this.ctx.destination);
                    osc.start(startTime);
                    osc.stop(startTime + duration);
                });
            }
        }

        // --- Confetti Logic ---
        class ConfettiSystem {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.particles = [];
                this.active = false;
                this.animationId = null;
                this.colors = ['#FFD700', '#FF0000', '#00FF00', '#0000FF', '#FF00FF', '#00FFFF', '#FFFFFF'];
                
                this.resize = this.resize.bind(this);
                window.addEventListener('resize', this.resize);
                this.resize();
            }

            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            start() {
                this.active = true;
                this.particles = [];
                for (let i = 0; i < 150; i++) {
                    this.particles.push({
                        x: window.innerWidth / 2,
                        y: window.innerHeight / 2,
                        vx: (Math.random() - 0.5) * 20,
                        vy: (Math.random() - 0.5) * 20 - 5,
                        gravity: 0.2,
                        color: this.colors[Math.floor(Math.random() * this.colors.length)],
                        size: Math.random() * 8 + 4,
                        rotation: Math.random() * 360,
                        rotationSpeed: (Math.random() - 0.5) * 10
                    });
                }
                this.animate();
            }

            stop() {
                this.active = false;
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                if (this.animationId) cancelAnimationFrame(this.animationId);
            }

            animate() {
                if (!this.active) return;
                
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.particles.forEach((p) => {
                    p.vy += p.gravity;
                    p.x += p.vx;
                    p.y += p.vy;
                    p.rotation += p.rotationSpeed;
                    p.vx *= 0.99;

                    this.ctx.save();
                    this.ctx.translate(p.x, p.y);
                    this.ctx.rotate((p.rotation * Math.PI) / 180);
                    this.ctx.fillStyle = p.color;
                    this.ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
                    this.ctx.restore();
                });

                // Remove off-screen
                this.particles = this.particles.filter(p => p.y < this.canvas.height + 50);

                if (this.particles.length > 0) {
                    this.animationId = requestAnimationFrame(this.animate.bind(this));
                } else {
                    this.active = false;
                }
            }
        }

        // --- Storage Logic ---
        const STORAGE_KEY = 'grand_roulette_settings_v2'; // Changed Key due to structure change

        function saveToStorage(stateData) {
            try {
                // Save Segments and Shuffle flag
                const data = {
                    segments: stateData.segments,
                    shuffle: stateData.shuffle
                };
                localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
            } catch (e) {
                console.warn('Failed to save settings:', e);
            }
        }

        function loadFromStorage() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (saved) {
                    const parsed = JSON.parse(saved);
                    // Migration check: if it's an array (old version), wrap it
                    if (Array.isArray(parsed)) {
                        return { segments: parsed, shuffle: false };
                    }
                    return parsed;
                }
                
                // Fallback: check v1 key
                const savedV1 = localStorage.getItem('grand_roulette_settings_v1');
                if (savedV1) {
                    return { segments: JSON.parse(savedV1), shuffle: false };
                }

                return null;
            } catch (e) {
                console.warn('Failed to load settings:', e);
                return null;
            }
        }

        function clearStorage() {
            try {
                localStorage.removeItem(STORAGE_KEY);
                localStorage.removeItem('grand_roulette_settings_v1');
                location.reload(); 
            } catch (e) {
                console.warn('Failed to clear storage:', e);
            }
        }

        // --- Main App Logic ---
        const soundFX = new SoundFX();
        const confetti = new ConfettiSystem('confettiCanvas');
        
        // Initial Defaults
        const defaultSegments = [
            { id: 1, text: '特賞: 旅行券', weight: 1, color: '#FFD700', textColor: '#000000' },
            { id: 2, text: '和牛ステーキ', weight: 3, color: '#C0392B', textColor: '#FFFFFF' },
            { id: 3, text: 'アマギフ 5k', weight: 5, color: '#8E44AD', textColor: '#FFFFFF' },
            { id: 4, text: 'お菓子詰め合わせ', weight: 10, color: '#27AE60', textColor: '#FFFFFF' },
            { id: 5, text: 'ハズレ', weight: 20, color: '#2C3E50', textColor: '#FFFFFF' },
            { id: 6, text: 'もう一回', weight: 5, color: '#2980B9', textColor: '#FFFFFF' },
        ];

        // Load or Default
        const loadedData = loadFromStorage();
        const initialSegments = loadedData ? loadedData.segments : defaultSegments;
        const initialShuffle = loadedData ? (loadedData.shuffle || false) : false;

        // Initial State
        let state = {
            segments: initialSegments,
            shuffle: initialShuffle,
            // activeSegments: calculated segments list used for drawing and physics
            activeSegments: [], 
            isSpinning: false,
            rotation: 0,
            soundEnabled: true,
            showSettings: false
        };

        // DOM Elements
        const canvas = document.getElementById('wheelCanvas');
        const ctx = canvas.getContext('2d');
        const spinBtn = document.getElementById('spinBtn');
        const settingsPanel = document.getElementById('settingsPanel');
        const settingsToggleBtn = document.getElementById('settingsToggleBtn');
        const segmentsList = document.getElementById('segmentsList');
        const addSegmentBtn = document.getElementById('addSegmentBtn');
        const soundToggleBtn = document.getElementById('soundToggleBtn');
        const winnerModal = document.getElementById('winnerModal');
        const winnerName = document.getElementById('winnerName');
        const closeModalBtn = document.getElementById('closeModalBtn');
        const modalCloseActionBtn = document.getElementById('modalCloseActionBtn');
        const modalOverlay = document.getElementById('modalOverlay');
        const gameTitle = document.getElementById('gameTitle');
        const resetStorageBtn = document.getElementById('resetStorageBtn');
        const shuffleToggle = document.getElementById('shuffleToggle');

        // Constants
        const CANVAS_SIZE = 600;
        const CENTER = CANVAS_SIZE / 2;
        const RADIUS = CANVAS_SIZE / 2 - 20;

        // --- Functions ---

        /**
         * Recalculates 'activeSegments' based on shuffle mode.
         * If shuffle is OFF: activeSegments is just a mapped copy of segments.
         * If shuffle is ON: activeSegments contains (weight) amount of slices for each segment, shuffled.
         */
        function recalculateActiveSegments() {
            if (!state.shuffle) {
                // Normal Mode
                state.activeSegments = state.segments.map(s => ({
                    ...s,
                    originalId: s.id,
                    displayWeight: parseInt(s.weight) // Draw based on full weight
                }));
            } else {
                // Shuffle Mode
                let list = [];
                state.segments.forEach(seg => {
                    const count = parseInt(seg.weight);
                    for(let i=0; i<count; i++) {
                        list.push({
                            ...seg,
                            originalId: seg.id,
                            displayWeight: 1 // Each slice has weight 1
                        });
                    }
                });
                
                // Fisher-Yates Shuffle
                for (let i = list.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [list[i], list[j]] = [list[j], list[i]];
                }
                
                state.activeSegments = list;
            }
        }

        function drawWheel() {
            ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            
            // Apply current rotation to canvas CSS for smooth animation
            canvas.style.transform = `rotate(${state.rotation}deg)`;

            // --- Draw Static Elements on Context (Canvas itself is rotated by CSS) ---
            // Actually, we must draw segments on the canvas. 
            // The canvas logic here draws segments assuming rotation=0 (upright).
            // The CSS rotates the whole view.

            const totalDisplayWeight = state.activeSegments.reduce((acc, seg) => acc + seg.displayWeight, 0);
            let currentAngle = 0;

            // 1. Draw Segments
            state.activeSegments.forEach((seg) => {
                const sliceAngle = (seg.displayWeight / totalDisplayWeight) * 2 * Math.PI;
                
                // Wedge
                ctx.beginPath();
                ctx.moveTo(CENTER, CENTER);
                ctx.arc(CENTER, CENTER, RADIUS, currentAngle, currentAngle + sliceAngle);
                ctx.closePath();
                ctx.fillStyle = seg.color;
                ctx.fill();
                ctx.stroke();

                // Text
                // If shuffled and slice is small (weight 1), text might be crowded. 
                // Only draw text if slice is big enough or if it's the only way?
                // For "Shuffle Mode", slices are small. Let's adjust font size or hide text if too small?
                // Let's try drawing it but maybe smaller if shuffle is on.
                
                ctx.save();
                ctx.translate(CENTER, CENTER);
                ctx.rotate(currentAngle + sliceAngle / 2);
                ctx.textAlign = 'right';
                ctx.fillStyle = seg.textColor;
                
                // Adjust font based on angle size to prevent overlap
                const angleDeg = (sliceAngle * 180) / Math.PI;
                let fontSize = 24;
                if (angleDeg < 10) fontSize = 12;
                else if (angleDeg < 20) fontSize = 16;
                
                ctx.font = `bold ${fontSize}px "Noto Sans JP", sans-serif`;
                ctx.shadowColor = 'rgba(0,0,0,0.5)';
                ctx.shadowBlur = 4;
                
                // Only draw text if it fits reasonably
                if (angleDeg > 3) {
                     ctx.fillText(seg.text, RADIUS - 40, fontSize/3);
                }
               
                ctx.restore();

                currentAngle += sliceAngle;
            });
            
            // Restore context for static overlays? 
            // No, ctx is just pixels. We drew the wheel.
            // Now draw borders/center on top.

            // 2. Draw Outer Border (This spins with the canvas in CSS mode)
            ctx.beginPath();
            ctx.arc(CENTER, CENTER, RADIUS, 0, Math.PI * 2);
            ctx.lineWidth = 4;
            ctx.strokeStyle = '#D4AF37'; // Inner gold rim
            ctx.stroke();
            
            ctx.beginPath();
            ctx.arc(CENTER, CENTER, RADIUS + 5, 0, Math.PI * 2);
            ctx.lineWidth = 10;
            ctx.strokeStyle = '#D4AF37'; // Outer gold rim
            ctx.stroke();

            // 3. Inner Center Decoration
            ctx.beginPath();
            ctx.arc(CENTER, CENTER, 40, 0, Math.PI * 2);
            ctx.fillStyle = '#222';
            ctx.fill();
            ctx.lineWidth = 4;
            ctx.strokeStyle = '#D4AF37';
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(CENTER, CENTER, 15, 0, Math.PI * 2);
            ctx.fillStyle = '#D4AF37';
            ctx.fill();
        }

        function renderSettings() {
            // Update Checkbox
            shuffleToggle.checked = state.shuffle;

            segmentsList.innerHTML = '';
            state.segments.forEach((seg, index) => {
                const div = document.createElement('div');
                div.className = 'bg-slate-800 p-4 rounded-xl border border-slate-700 shadow-sm animate-fadeIn';
                div.innerHTML = `
                    <div class="flex gap-2 mb-2">
                        <input type="text" value="${seg.text}" data-id="${seg.id}" class="seg-text flex-1 bg-slate-900 border border-slate-600 rounded px-3 py-1 text-sm focus:border-yellow-500 outline-none transition-colors" placeholder="項目名">
                        <input type="color" value="${seg.color}" data-id="${seg.id}" class="seg-color w-10 h-8 rounded cursor-pointer border-none bg-transparent">
                    </div>
                    <div class="flex items-center gap-4">
                        <div class="flex-1 flex flex-col">
                            <label class="text-xs text-slate-400 mb-1">比率 (確率): ${seg.weight}</label>
                            <input type="range" min="1" max="50" value="${seg.weight}" data-id="${seg.id}" class="seg-weight w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-yellow-500">
                        </div>
                        ${state.segments.length > 2 ? `<button data-id="${seg.id}" class="seg-delete p-2 text-red-400 hover:bg-red-400/10 rounded-full transition-colors"><i data-lucide="trash-2" class="w-4 h-4"></i></button>` : ''}
                    </div>
                `;
                segmentsList.appendChild(div);
            });
            lucide.createIcons();

            // Attach listeners
            document.querySelectorAll('.seg-text').forEach(el => {
                el.addEventListener('input', (e) => updateSegment(parseInt(e.target.dataset.id), 'text', e.target.value));
            });
            document.querySelectorAll('.seg-color').forEach(el => {
                el.addEventListener('input', (e) => updateSegment(parseInt(e.target.dataset.id), 'color', e.target.value));
            });
            document.querySelectorAll('.seg-weight').forEach(el => {
                el.addEventListener('input', (e) => updateSegment(parseInt(e.target.dataset.id), 'weight', parseInt(e.target.value)));
            });
            document.querySelectorAll('.seg-delete').forEach(el => {
                el.addEventListener('click', (e) => {
                    const id = parseInt(e.currentTarget.dataset.id);
                    removeSegment(id);
                });
            });
        }

        function updateSegment(id, field, value) {
            const seg = state.segments.find(s => s.id === id);
            if (seg) {
                seg[field] = value;
                recalculateActiveSegments();
                drawWheel();
                saveToStorage(state);
                
                if (field === 'weight') {
                     const label = document.querySelector(`input[data-id="${id}"].seg-weight`).previousElementSibling;
                     label.textContent = `比率 (確率): ${value}`;
                }
            }
        }

        function addSegment() {
            const newId = (state.segments.length > 0 ? Math.max(...state.segments.map(s => s.id)) : 0) + 1;
            state.segments.push({ id: newId, text: '新規項目', weight: 1, color: '#bdc3c7', textColor: '#000' });
            renderSettings();
            recalculateActiveSegments();
            drawWheel();
            saveToStorage(state);
        }

        function removeSegment(id) {
            if (state.segments.length <= 2) return;
            state.segments = state.segments.filter(s => s.id !== id);
            renderSettings();
            recalculateActiveSegments();
            drawWheel();
            saveToStorage(state);
        }

        function toggleShuffle() {
            state.shuffle = shuffleToggle.checked;
            recalculateActiveSegments();
            drawWheel();
            saveToStorage(state);
        }

        function toggleSettings() {
            state.showSettings = !state.showSettings;
            if (state.showSettings) {
                settingsPanel.classList.remove('-translate-x-full');
                settingsToggleBtn.classList.add('bg-slate-800', 'text-white');
                settingsToggleBtn.classList.remove('bg-yellow-500', 'text-black');
                settingsToggleBtn.innerHTML = '<i data-lucide="chevron-left" class="w-6 h-6"></i>';
            } else {
                settingsPanel.classList.add('-translate-x-full');
                settingsToggleBtn.classList.remove('bg-slate-800', 'text-white');
                settingsToggleBtn.classList.add('bg-yellow-500', 'text-black');
                settingsToggleBtn.innerHTML = '<i data-lucide="settings" class="w-6 h-6"></i>';
            }
            lucide.createIcons();
        }

        function toggleSound() {
            state.soundEnabled = !state.soundEnabled;
            soundFX.enabled = state.soundEnabled;
            if (state.soundEnabled) {
                soundFX.init();
                document.getElementById('soundIcon').setAttribute('data-lucide', 'volume-2');
                document.getElementById('soundIcon').classList.replace('text-red-400', 'text-green-400');
            } else {
                document.getElementById('soundIcon').setAttribute('data-lucide', 'volume-x');
                document.getElementById('soundIcon').classList.replace('text-green-400', 'text-red-400');
            }
            lucide.createIcons();
        }

        function spin() {
            if (state.isSpinning) return;
            
            soundFX.init();
            state.isSpinning = true;
            
            // UI Update
            spinBtn.disabled = true;
            spinBtn.classList.add('bg-slate-800', 'text-slate-500', 'scale-90', 'cursor-not-allowed', 'opacity-80');
            spinBtn.classList.remove('bg-gradient-to-br', 'from-red-600', 'to-red-800', 'text-white', 'hover:scale-110', 'animate-pulse-slow');
            spinBtn.textContent = '...';
            gameTitle.classList.add('opacity-50', 'scale-90');
            
            if(state.showSettings) toggleSettings();

            // 1. Determine Winning Segment based on pure weight probability
            const totalWeight = state.segments.reduce((acc, seg) => acc + parseInt(seg.weight), 0);
            let random = Math.random() * totalWeight;
            let resultSegment = null;
            
            for (let seg of state.segments) {
                if (random < parseInt(seg.weight)) {
                    resultSegment = seg;
                    break;
                }
                random -= parseInt(seg.weight);
            }

            // 2. Find target slice in activeSegments (drawing list)
            // If shuffled, there are multiple slices with originalId === resultSegment.id.
            // Pick one randomly.
            const targetCandidates = [];
            let angleAccumulator = 0;
            const totalDisplayWeight = state.activeSegments.reduce((acc,s) => acc + s.displayWeight, 0);

            state.activeSegments.forEach(seg => {
                const segAngle = (seg.displayWeight / totalDisplayWeight) * 360;
                // Check if this slice belongs to the winner
                if (seg.originalId === resultSegment.id) {
                    targetCandidates.push({
                        start: angleAccumulator,
                        end: angleAccumulator + segAngle
                    });
                }
                angleAccumulator += segAngle;
            });

            // Randomly pick one of the candidate slices
            const targetSlice = targetCandidates[Math.floor(Math.random() * targetCandidates.length)];

            // 3. Calculate Rotation to land on targetSlice
            // We want a random point within this slice to land at 270deg (Top)
            const pad = Math.min((targetSlice.end - targetSlice.start) * 0.2, 5); 
            const randomOffset = Math.random() * (targetSlice.end - targetSlice.start - 2 * pad) + pad;
            const targetAngleWithinWheel = targetSlice.start + randomOffset;

            const spins = 5;
            const duration = 6000;
            const startRotation = state.rotation;
            
            const currentMod = startRotation % 360;
            const targetRotationBase = 270 - targetAngleWithinWheel; 
            const totalRotation = startRotation + (360 * spins) + (targetRotationBase - currentMod + 360) % 360;

            const startTime = performance.now();
            let lastTickSection = -1;

            const animate = (currentTime) => {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                const ease = 1 - Math.pow(1 - progress, 4);
                state.rotation = startRotation + (totalRotation - startRotation) * ease;
                
                // Draw/Rotate
                canvas.style.transform = `rotate(${state.rotation}deg)`;

                // Sound Logic
                const normRot = state.rotation % 360;
                let pointerAngleInWheel = (270 - normRot) % 360;
                if (pointerAngleInWheel < 0) pointerAngleInWheel += 360;

                let currentSegIndex = 0;
                let accum = 0;
                
                // Need to match slice index in activeSegments
                for(let i=0; i<state.activeSegments.length; i++) {
                    const w = (state.activeSegments[i].displayWeight / totalDisplayWeight) * 360;
                    if (pointerAngleInWheel >= accum && pointerAngleInWheel < accum + w) {
                        currentSegIndex = i;
                        break;
                    }
                    accum += w;
                }

                if (currentSegIndex !== lastTickSection) {
                    soundFX.playTick();
                    lastTickSection = currentSegIndex;
                }

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    finishSpin(resultSegment);
                }
            };

            requestAnimationFrame(animate);
        }

        function finishSpin(result) {
            state.isSpinning = false;
            soundFX.playWin();
            
            winnerName.textContent = result.text;
            winnerModal.classList.remove('hidden');
            confetti.start();

            spinBtn.disabled = false;
            spinBtn.classList.remove('bg-slate-800', 'text-slate-500', 'scale-90', 'cursor-not-allowed', 'opacity-80');
            spinBtn.classList.add('bg-gradient-to-br', 'from-red-600', 'to-red-800', 'text-white', 'hover:scale-110', 'animate-pulse-slow');
            spinBtn.textContent = 'SPIN';
            gameTitle.classList.remove('opacity-50', 'scale-90');
        }

        function closeWinnerModal() {
            winnerModal.classList.add('hidden');
            confetti.stop();
        }

        // --- Event Listeners & Init ---
        settingsToggleBtn.addEventListener('click', toggleSettings);
        soundToggleBtn.addEventListener('click', toggleSound);
        addSegmentBtn.addEventListener('click', addSegment);
        spinBtn.addEventListener('click', spin);
        resetStorageBtn.addEventListener('click', () => {
            if(confirm('設定をすべてリセットしますか？')) {
                clearStorage();
            }
        });
        shuffleToggle.addEventListener('change', toggleShuffle);
        
        closeModalBtn.addEventListener('click', closeWinnerModal);
        modalCloseActionBtn.addEventListener('click', closeWinnerModal);
        modalOverlay.addEventListener('click', closeWinnerModal);

        // Resize Canvas Logic
        window.addEventListener('resize', () => {
             // Redraw if needed
        });

        // Initialize
        lucide.createIcons();
        renderSettings();
        recalculateActiveSegments(); // Init active segments
        drawWheel();
        
    </script>
</body>
</html>
